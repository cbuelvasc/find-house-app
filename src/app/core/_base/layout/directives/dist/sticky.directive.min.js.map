{"version":3,"sources":["sticky.directive.ts"],"names":["core_1","require","common_1","rxjs_1","animationFrame_1","operators_1","StickyDirective","stickyElement","platformId","_this","this","filterGate","marginTop$","BehaviorSubject","marginBottom$","enable$","sticky","boundaryReached","scroll$","Subject","resize$","extraordinaryChange$","undefined","componentDestroyed","listener","e","upperScreenEdgeAt","target","scrollTop","window","pageYOffset","next","scrollThrottled$","pipe","throttleTime","animationFrame","share","resizeThrottled$","startWith","status$","combineLatest","filter","_a","enabled","checkEnabled","map","marginTop","marginBottom","determineStatus","determineElementOffsets","Object","defineProperty","prototype","value","ngAfterViewInit","takeUntil","subscribe","status","setSticky","recalculate","isPlatformBrowser","setTimeout","onWindowResize","setupListener","getScrollTarget","addEventListener","removeListener","removeEventListener","ngOnInit","ngOnDestroy","getComputedStyle","el","getBoundingClientRect","scrollContainer","document","querySelector","HTMLElement","originalVals","stickyElementHeight","nativeElement","height","reachedLowerEdge","boundaryElement","bottomBoundary","isSticky","offsetY","removeSticky","getPosition","y","makeSticky","width","left","bottom","style","position","backgroundColor","top","zIndex","spacerElement","spacerHeight","checkSetup","isDevMode","console","warn","__decorate","Input","HostBinding","HostListener","Directive","selector","__param","Inject","PLATFORM_ID","element","offsetTop","offsetLeft","offsetParent","x","exports"],"mappings":"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","file":"sticky.directive.min.js","sourcesContent":["import {\r\n  AfterViewInit,\r\n  Directive,\r\n  ElementRef,\r\n  HostBinding,\r\n  HostListener,\r\n  Inject,\r\n  Input,\r\n  isDevMode,\r\n  OnDestroy,\r\n  OnInit,\r\n  PLATFORM_ID\r\n} from '@angular/core';\r\nimport { isPlatformBrowser } from '@angular/common';\r\nimport { BehaviorSubject, combineLatest, Observable, Subject } from 'rxjs';\r\nimport { animationFrame } from 'rxjs/internal/scheduler/animationFrame';\r\nimport { filter, map, share, startWith, takeUntil, throttleTime } from 'rxjs/operators';\r\n\r\nexport interface StickyPositions {\r\n  offsetY: number;\r\n  bottomBoundary: number | null;\r\n}\r\n\r\nexport interface StickyStatus {\r\n  isSticky: boolean;\r\n  reachedLowerEdge: boolean;\r\n  marginTop: number;\r\n  marginBottom: number;\r\n}\r\n\r\n@Directive({\r\n  selector: '[appSticky]'\r\n})\r\nexport class StickyDirective implements OnInit, AfterViewInit, OnDestroy {\r\n\r\n  filterGate = false;\r\n  marginTop$ = new BehaviorSubject(0);\r\n  marginBottom$ = new BehaviorSubject(0);\r\n  enable$ = new BehaviorSubject(true);\r\n\r\n  @Input() scrollContainer: string | HTMLElement;\r\n  // tslint:disable-next-line\r\n  @Input('spacerElement') spacerElement: HTMLElement | undefined;\r\n  // tslint:disable-next-line\r\n  @Input('boundaryElement') boundaryElement: HTMLElement | undefined;\r\n  @HostBinding('class.is-sticky') sticky = false;\r\n  @HostBinding('class.boundary-reached') boundaryReached = false;\r\n\r\n\r\n  private scroll$ = new Subject<number>();\r\n  private scrollThrottled$: Observable<number>;\r\n  private resize$ = new Subject<void>();\r\n  private resizeThrottled$: Observable<void>;\r\n  private extraordinaryChange$ = new BehaviorSubject<void>(undefined);\r\n  private status$: Observable<StickyStatus>;\r\n  private componentDestroyed = new Subject<void>();\r\n\r\n  constructor(private stickyElement: ElementRef, @Inject(PLATFORM_ID) private platformId: string) {\r\n\r\n    /** Throttle the scroll to animation frame (around 16.67ms) */\r\n    this.scrollThrottled$ = this.scroll$\r\n      .pipe(\r\n        throttleTime(0, animationFrame),\r\n        share()\r\n      );\r\n\r\n    /** Throttle the resize to animation frame (around 16.67ms) */\r\n    this.resizeThrottled$ = this.resize$\r\n      .pipe(\r\n        throttleTime(0, animationFrame),\r\n        // emit once since we are currently using combineLatest\r\n        startWith(null),\r\n        share()\r\n      );\r\n\r\n    this.status$ = combineLatest(\r\n      this.enable$,\r\n      this.scrollThrottled$,\r\n      this.marginTop$,\r\n      this.marginBottom$,\r\n      this.extraordinaryChange$,\r\n      this.resizeThrottled$,\r\n    )\r\n      .pipe(\r\n        filter(([enabled]) => this.checkEnabled(enabled)),\r\n        map(([enabled, pageYOffset, marginTop, marginBottom]) =>\r\n          this.determineStatus(this.determineElementOffsets(), pageYOffset, marginTop, marginBottom, enabled)),\r\n        share(),\r\n      );\r\n  }\r\n\r\n  @Input() set marginTop(value: number) {\r\n    this.marginTop$.next(value);\r\n  }\r\n\r\n  @Input() set marginBottom(value: number) {\r\n    this.marginBottom$.next(value);\r\n  }\r\n\r\n  @Input() set enable(value: boolean) {\r\n    this.enable$.next(value);\r\n  }\r\n\r\n  ngAfterViewInit(): void {\r\n    this.status$\r\n      .pipe(takeUntil(this.componentDestroyed))\r\n      .subscribe((status) => this.setSticky(status));\r\n  }\r\n\r\n  public recalculate(): void {\r\n    if (isPlatformBrowser(this.platformId)) {\r\n      // Make sure to be in the next tick by using timeout\r\n      setTimeout(() => {\r\n        this.extraordinaryChange$.next(undefined);\r\n      }, 0);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * This is nasty code that should be refactored at some point.\r\n   *\r\n   * The Problem is, we filter for enabled. So that the code doesn't run\r\n   * if @Input enabled = false. But if the user disables, we need exactly 1\r\n   * emit in order to reset and call removeSticky. So this method basically\r\n   * turns the filter in \"filter, but let the first pass\".\r\n   */\r\n  checkEnabled(enabled: boolean): boolean {\r\n\r\n    if (!isPlatformBrowser(this.platformId)) {\r\n      return false;\r\n    }\r\n\r\n    if (enabled) {\r\n      // reset the gate\r\n      this.filterGate = false;\r\n      return true;\r\n    } else {\r\n      if (this.filterGate) {\r\n        // gate closed, first emit has happened\r\n        return false;\r\n      } else {\r\n        // this is the first emit for enabled = false,\r\n        // let it pass, and activate the gate\r\n        // so the next wont pass.\r\n        this.filterGate = true;\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  @HostListener('window:resize', [])\r\n  onWindowResize(): void {\r\n    if (isPlatformBrowser(this.platformId)) {\r\n      this.resize$.next();\r\n    }\r\n  }\r\n\r\n  setupListener(): void {\r\n    if (isPlatformBrowser(this.platformId)) {\r\n      const target = this.getScrollTarget();\r\n      target.addEventListener('scroll', this.listener);\r\n    }\r\n  }\r\n\r\n  removeListener() {\r\n    if (isPlatformBrowser(this.platformId)) {\r\n      const target = this.getScrollTarget();\r\n      target.removeEventListener('scroll', this.listener);\r\n    }\r\n  }\r\n\r\n  listener = (e: Event) => {\r\n    const upperScreenEdgeAt = (e.target as HTMLElement).scrollTop || window.pageYOffset;\r\n    this.scroll$.next(upperScreenEdgeAt);\r\n  }\r\n\r\n  ngOnInit(): void {\r\n    // this.checkSetup();\r\n    this.setupListener();\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.componentDestroyed.next();\r\n    this.removeListener();\r\n  }\r\n\r\n  getComputedStyle(el: HTMLElement): ClientRect | DOMRect {\r\n    return el.getBoundingClientRect();\r\n  }\r\n\r\n  private getScrollTarget(): Element | Window {\r\n\r\n    let target: Element | Window;\r\n\r\n    if (this.scrollContainer && typeof this.scrollContainer === 'string') {\r\n      target = document.querySelector(this.scrollContainer);\r\n    } else if (this.scrollContainer && this.scrollContainer instanceof HTMLElement) {\r\n      target = this.scrollContainer;\r\n    } else {\r\n      target = window;\r\n    }\r\n    return target;\r\n  }\r\n\r\n  private determineStatus(originalVals: StickyPositions,\r\n    pageYOffset: number,\r\n    marginTop: number,\r\n    marginBottom: number,\r\n    enabled: boolean): StickyStatus {\r\n    const stickyElementHeight = this.getComputedStyle(this.stickyElement.nativeElement).height;\r\n    const reachedLowerEdge = this.boundaryElement &&\r\n      window.pageYOffset + stickyElementHeight + marginBottom >= (originalVals.bottomBoundary - marginTop);\r\n    return {\r\n      isSticky: enabled && pageYOffset > originalVals.offsetY,\r\n      reachedLowerEdge,\r\n      marginBottom,\r\n      marginTop,\r\n    };\r\n  }\r\n\r\n\r\n  /**\r\n   * Gets the offset for element. If the element\r\n   * currently is sticky, it will get removed\r\n   * to access the original position. Other\r\n   * wise this would just be 0 for fixed elements.\r\n   */\r\n  private determineElementOffsets(): StickyPositions {\r\n    if (this.sticky) {\r\n      this.removeSticky();\r\n    }\r\n\r\n    let bottomBoundary: number | null = null;\r\n\r\n    if (this.boundaryElement) {\r\n      const boundaryElementHeight = this.getComputedStyle(this.boundaryElement).height;\r\n      const boundaryElementOffset = getPosition(this.boundaryElement).y;\r\n      bottomBoundary = boundaryElementHeight + boundaryElementOffset;\r\n    }\r\n\r\n    return { offsetY: (getPosition(this.stickyElement.nativeElement).y - this.marginTop$.value), bottomBoundary };\r\n  }\r\n\r\n  private makeSticky(boundaryReached: boolean = false, marginTop: number, marginBottom: number): void {\r\n\r\n    this.boundaryReached = boundaryReached;\r\n\r\n    // do this before setting it to pos:fixed\r\n    const { width, height, left } = this.getComputedStyle(this.stickyElement.nativeElement);\r\n    const offSet = boundaryReached ?\r\n      (this.getComputedStyle(this.boundaryElement).bottom - height - this.marginBottom$.value) : this.marginTop$.value;\r\n\r\n    this.sticky = true;\r\n    this.stickyElement.nativeElement.style.position = 'sticky';\r\n    this.stickyElement.nativeElement.style.backgroundColor = '#fff';\r\n    this.stickyElement.nativeElement.style.top = this.marginTop$.value + 'px';\r\n    // this.stickyElement.nativeElement.style.left = left + 'px';\r\n    this.stickyElement.nativeElement.style.width = `${width}px`;\r\n    this.stickyElement.nativeElement.style.zIndex = `2`;\r\n    if (this.spacerElement) {\r\n      const spacerHeight = marginBottom + height + marginTop;\r\n      this.spacerElement.style.height = `${spacerHeight}px`;\r\n    }\r\n  }\r\n\r\n  private checkSetup() {\r\n    if (isDevMode() && !this.spacerElement) {\r\n      console.warn(`******There might be an issue with your sticky directive!******\r\n\r\nYou haven't specified a spacer element. This will cause the page to jump.\r\n\r\nBest practise is to provide a spacer element (e.g. a div) right before/after the sticky element.\r\nThen pass the spacer element as input:\r\n\r\n<div #spacer></div>\r\n\r\n<div stickyThing=\"\" [spacer]=\"spacer\">\r\n    I am sticky!\r\n</div>`);\r\n    }\r\n  }\r\n\r\n\r\n  private setSticky(status: StickyStatus): void {\r\n    if (status.isSticky) {\r\n      this.makeSticky(status.reachedLowerEdge, status.marginTop, status.marginBottom);\r\n    } else {\r\n      this.removeSticky();\r\n    }\r\n  }\r\n\r\n  private removeSticky(): void {\r\n\r\n    this.boundaryReached = false;\r\n    this.sticky = false;\r\n\r\n    this.stickyElement.nativeElement.style.position = '';\r\n    this.stickyElement.nativeElement.style.width = 'auto';\r\n    this.stickyElement.nativeElement.style.left = 'auto';\r\n    this.stickyElement.nativeElement.style.top = 'auto';\r\n    if (this.spacerElement) {\r\n      this.spacerElement.style.height = '0';\r\n    }\r\n  }\r\n}\r\n\r\n// Thanks to https://stanko.github.io/javascript-get-element-offset/\r\nfunction getPosition(el) {\r\n  let top = 0;\r\n  let left = 0;\r\n  let element = el;\r\n\r\n  // Loop through the DOM tree\r\n  // and add it's parent's offset to get page offset\r\n  do {\r\n    top += element.offsetTop || 0;\r\n    left += element.offsetLeft || 0;\r\n    element = element.offsetParent;\r\n  } while (element);\r\n\r\n  return {\r\n    y: top,\r\n    x: left,\r\n  };\r\n}\r\n"]}